import { promises } from 'node:fs';
import MagicString from 'magic-string';
import { addServerTemplate } from './_utils';
import type { ModuleOptions } from '../types';
import { pascalCase } from '@whoj/utils-core';
import { createFilter } from '@rollup/pluginutils';
import { BoxClient } from 'box-typescript-sdk-gen/lib/client.generated.js';
import { addImportsSources, addServerImports, addTemplate, addTypeTemplate, resolvePath, useNuxt } from '@nuxt/kit';

export function registerImports(resolve: (...p: string[]) => string, options: ModuleOptions, nuxt = useNuxt()) {
  const managerImports = createClientClass(options, nuxt);

  if (options.mode !== 'server') {
    const sources = [{
      from: resolve('./runtime/composables/auth'),
      imports: ['useBoxAuth']
    }, {
      from: resolve('./runtime/composables/client'),
      imports: ['useBoxClient', 'useBoxBasicClient', 'createBoxClient']
    }];

    if (options.managers?.composables !== false) {
      sources.push({
        from: '#nuxt/box-sdk/managers',
        imports: managerImports
      });
    }
    addImportsSources(sources);
  }

  if (options.mode !== 'client') {
    const imports = [
      ...([
        'useBoxAuth',
        'useBoxCcgAuth',
        'useBoxOAuth',
        'useBoxJwtAuth',
        'useBoxAuthConfig'
      ].map(name => ({ name, from: resolve('./runtime/server/utils/auth') }))),
      { name: 'useBoxTokenStorage', from: resolve('./runtime/server/utils/storage') },
      ...([
        'useBoxClient',
        'useBoxCcgClient',
        'useBoxJwtClient',
        'useBoxOAuthClient'
      ].map(name => ({ name, from: resolve('./runtime/server/utils/client') })))
    ];

    if (options.managers?.composables !== false) {
      managerImports.forEach((name) => {
        imports.push({ name, from: '#nuxt/box-sdk/managers' });
      });
    }

    addServerImports(imports);
  }
}

function createClientClass(options: ModuleOptions, nuxt = useNuxt()) {
  const filter = createFilter(options.managers?.include, options.managers?.exclude, { resolve: false });

  const _managersAvailable = Object.getOwnPropertyNames(new BoxClient({} as any))
    .filter(n => !['auth', 'networkSession'].includes(n));
  const managers = _managersAvailable.filter(filter);

  const _imports = [
    '// Auto-Generated by \'nuxt-box-typescript-sdk\'',
    'import { fetch } from \'box-typescript-sdk-gen/lib/networking/fetch.js\';',
    'import { BaseUrls } from \'box-typescript-sdk-gen/lib/networking/baseUrls.generated.js\';',
    'import { NetworkSession } from \'box-typescript-sdk-gen/lib/networking/network.generated.js\';',
    'import { FetchOptions } from \'box-typescript-sdk-gen/lib/networking/fetchOptions.generated.js\';'
  ];

  const _composablesImports = [];
  const _composablesDtsImports = [
    'import type { BoxManager, BoxManagerNetworkSession } from \'#nuxt/box-sdk/types\';',
    'import type { Authentication } from \'box-typescript-sdk-gen/lib/networking/auth.generated.js\';'
  ];

  const _composables: string[] = [];
  const _autoImports: string[] = [];
  const _composablesDts: string[] = [];

  const s = new MagicString(`
export class BoxClient {
  constructor(fields) {
    this.networkSession = fields.networkSession ?? new NetworkSession({
      baseUrls: new BaseUrls({}),
    });
    if (fields.auth) {
      this.auth = fields.auth;
    }`);

  for (const manager of managers) {
    const managerImport = `import { ${pascalCase(`${manager}Manager`)} } from 'box-typescript-sdk-gen/lib/managers/${manager}.generated.js';`;
    _imports.push(managerImport);
    _composablesImports.push(managerImport);
    _composablesDtsImports.push(managerImport);
    s.append(`\n    this.${manager} = new ${pascalCase(`${manager}Manager`)}({\n      auth: this.auth,\n      networkSession: this.networkSession,\n    });\n`);

    _composables.push(`export const useBox${pascalCase(`${manager}Manager`)} = /*#__NO_SIDE_EFFECTS__*/ (auth, networkSession) => createBoxManager(${pascalCase(`${manager}Manager`)}, auth, networkSession);`);
    _composablesDts.push(`export declare const useBox${pascalCase(`${manager}Manager`)}: (auth?: Authentication, networkSession?: BoxManagerNetworkSession) => ReturnType<typeof createBoxManager<typeof ${pascalCase(`${manager}Manager`)}>>;`);

    _autoImports.push(`useBox${pascalCase(`${manager}Manager`)}`);
  }

  s.append('  }\n')
    .append(getInstanceMethods())
    .append('}\n');

  s.prepend(_imports.join('\n'));

  const { dst } = addTemplate({
    filename: 'modules/nuxt-box-typescript-sdk/client.mjs',
    getContents: () => s.toString()
  });

  addServerTemplate({
    filename: '#nuxt/box-sdk/client',
    getContents: () => s.toString()
  });

  addTypeTemplate({
    filename: 'modules/nuxt-box-typescript-sdk/client.d.ts',
    getContents: async () => {
      const dts = await createClientDts(managers, _managersAvailable);

      return dts.prepend('// Auto-Generated by \'nuxt-box-typescript\'\n').toString()
        .split('\n')
        .map((line) => {
          const exc = /import \{ (\w+) \} from '(.*)';/.exec(line);
          if (exc?.length && exc[2].startsWith('./')) {
            line = line.replace(exc[2], `box-typescript-sdk-gen/lib/${exc[2].substring(2)}`);
          }
          if (line.search(/\S|$/) > 4) {
            line = line.substring(line.search(/\S|$/) - 4);
          }

          const replaces: Array<[RegExp, string]> = [
            [/constructor\(fields: .*$/, 'constructor(fields: BoxClientInput<T>);'],
            [/export declare class BoxClient/, 'export declare class BoxClient<T extends Authentication = Authentication>'],
            [/export interface BoxClientInput/, 'export interface BoxClientInput<T extends Authentication = Authentication>'],
            [/readonly auth: Authentication/, 'readonly auth: T'],
            [/\): BoxClient;/, '): BoxClient<T>']
          ];

          for (const [regex, replace] of replaces) {
            if (regex.test(line)) {
              line = line.replace(regex, replace);
              break;
            }
          }

          return line;
        }).join('\n');
    }
  });

  nuxt.options.alias['#nuxt/box-sdk/client'] = dst.replace(/\.mjs$/i, '');

  if (options.managers?.composables) {
    const { dst: managersDst } = addTemplate({
      filename: 'modules/nuxt-box-typescript-sdk/managers.mjs',
      getContents: () => [
        '// Auto-Generated by \'nuxt-box-typescript-sdk\'',
        'import { hash } from \'ohash\';',
        'import { createError } from "#imports";',
        'import { computed, toValue } from \'vue\';',
        'import { isFunction, tap } from "@whoj/utils-core";',
        'import { createBoxManager as managerFactory } from \'#nuxt/box-sdk/utils\';',
        'import { FetchOptions } from "box-typescript-sdk-gen/lib/networking/fetchOptions.generated.js";',
        ..._composablesImports
      ].join('\n') + '\n\n' + _composables.join('\n') + `\nfunction createBoxManager (...args) {
  const [manager, auth, networkSession] = args;
  const Manager = class extends manager {
    withAsyncData(opts = {}) {
      return new Proxy(this, {
        get(target, prop) {
          if (target[prop] && isFunction(target[prop]) && !/with(?:AsUserHeader|SuppressedNotifications|ExtraHeaders|CustomBaseUrls|Proxy|CustomAgentOptions|Interceptors)/.test(prop)) {
            return (...args2) => {
              const _key = computed(() => {
                return \`box:\${manager.name}:\${hash([prop, ...args2.map((a) => toValue(a))])}\`;
              });
              let controller;
              return useAsyncData(
                _key.value,
                async (nuxt) => {
                  controller?.abort?.();
                  if (nuxt && nuxt.isHydrating && nuxt.payload.data[_key.value]) {
                    return nuxt.payload.data[_key.value];
                  }
                  controller = new AbortController();
                  const _target = target.withInterceptors([
                    {
                      beforeRequest(options) {
                        return { ...options, cancellationToken: controller.signal };
                      },
                      afterRequest: (response) => response
                    }
                  ]);
                  try {
                    let result = await _target[prop].call(_target, ...args2.map((a) => toValue(a)));
                    result = JSON.parse(JSON.stringify(result));
                    if (nuxt) {
                      nuxt.payload.data[_key.value] = result;
                    }
                    return tap(JSON.parse(JSON.stringify(result)), (_result) => {
                      return _result;
                    });
                  } catch (error) {
                    if (nuxt) {
                      nuxt.payload.data[_key.value] = void 0;
                    }
                    throw createError(error);
                  }
                },
                {
                  ...opts || {},
                  watch: [
                    ...opts?.watch || [],
                    () => toValue(args2)
                  ]
                }
              );
            };
          }
          return Reflect.get(target, prop);
        }
      });
    }
  };
  return managerFactory(Manager, auth, networkSession);
};`
    });

    addServerTemplate({
      filename: '#nuxt/box-sdk/managers',
      getContents: () => [
        '// Auto-Generated by \'nuxt-box-typescript-sdk\'',
        'import { createBoxManager } from \'#nuxt/box-sdk/utils\';',
        ..._composablesImports
      ].join('\n') + '\n\n' + _composables.join('\n')
    });

    addTypeTemplate({
      filename: 'modules/nuxt-box-typescript-sdk/managers.d.ts',
      getContents: () => [
        '// Auto-Generated by \'nuxt-box-typescript-sdk\'',
        'import type { MaybeRefOrGetter } from \'vue\';',
        'import type { Class } from \'@whoj/utils-types\';',
        'import type { AsyncData, AsyncDataOptions, NuxtError } from \'#app\';',
        'import { createBoxManager as managerFactory } from \'#nuxt/box-sdk/utils\';',
        ..._composablesDtsImports
      ].join('\n') + '\n\n' + _composablesDts.join('\n') + `\n\ntype KeysToExclude = 'auth' | 'networkSession' | 'withAsUserHeader' | 'withSuppressedNotifications' | 'withExtraHeaders' | 'withCustomBaseUrls' | 'withProxy' | 'withCustomAgentOptions' | 'withInterceptors';
type MaybeRefOrGetterArgs<T extends unknown[]> = T extends infer LNT ? {
    [L in keyof LNT]: MaybeRefOrGetter<T[L]>;
} : never;
type WithAsyncData<T extends Class<any>> = Class<Pick<T['prototype'], Extract<keyof T['prototype'], KeysToExclude>> & {
    [P in Exclude<keyof T['prototype'], KeysToExclude>]: T['prototype'][P] extends ((...args: infer A) => Promise<infer R>) ? ((...args: MaybeRefOrGetterArgs<A>) => AsyncData<R, NuxtError>) : T['prototype'][P];
}>;
declare function createBoxManager<T extends Class<any>>(...args: Parameters<typeof managerFactory<T>>): BoxManager<Class<T["prototype"] & {
    withAsyncData(opts?: AsyncDataOptions<any>): InstanceType<WithAsyncData<T>>;
}>>;`
    });
    nuxt.options.alias['#nuxt/box-sdk/managers'] = managersDst.replace(/\.mjs$/i, '');
  }

  return _autoImports;
}

function getInstanceMethods() {
  const _code = `  async makeRequest(fetchOptionsInput) {
    const fetchOptions = new FetchOptions({
      url: fetchOptionsInput.url,
      method: fetchOptionsInput.method,
      params: fetchOptionsInput.params,
      headers: fetchOptionsInput.headers,
      data: fetchOptionsInput.data,
      fileStream: fetchOptionsInput.fileStream,
      multipartData: fetchOptionsInput.multipartData,
      contentType: fetchOptionsInput.contentType,
      responseFormat: fetchOptionsInput.responseFormat,
      auth: fetchOptionsInput.auth,
      networkSession: fetchOptionsInput.networkSession,
      cancellationToken: fetchOptionsInput.cancellationToken,
      followRedirects: fetchOptionsInput.followRedirects,
    });
    const auth = fetchOptions.auth == void 0 ? this.auth : fetchOptions.auth;
    const networkSession = fetchOptions.networkSession == void 0
        ? this.networkSession
        : fetchOptions.networkSession;
    const enrichedFetchOptions = new FetchOptions({
      auth: auth,
      networkSession: networkSession,
      url: fetchOptions.url,
      method: fetchOptions.method,
      params: fetchOptions.params,
      headers: fetchOptions.headers,
      data: fetchOptions.data,
      fileStream: fetchOptions.fileStream,
      multipartData: fetchOptions.multipartData,
      contentType: fetchOptions.contentType,
      responseFormat: fetchOptions.responseFormat,
      followRedirects: fetchOptions.followRedirects,
    });
    return fetch(enrichedFetchOptions);
  }
`;

  return Object.getOwnPropertyNames(BoxClient.prototype)
    .filter(m => 'function' === typeof BoxClient.prototype[m] && !/constructor|makeRequest/.test(m))
    .reduce((code, m) => {
      let methodStr = `${BoxClient.prototype[m]}\n`;
      if (m === 'withCustomBaseUrls') {
        methodStr = methodStr.replace(/= new [\w+]+\.BaseUrls/, '= new BaseUrls');
      }

      return `${code}    ${methodStr}`;
    }, _code);
}

async function createClientDts(managers: string[], _managersAvailable: string[]) {
  const filename = await resolvePath('box-typescript-sdk-gen/lib/client.generated.d.ts');

  const dts = new MagicString(await promises.readFile(filename, 'utf8'));

  for (const managerAvailable of _managersAvailable) {
    if (!managers.includes(managerAvailable)) {
      dts.replace(
        new RegExp(`import { ${pascalCase(`${managerAvailable}Manager`)} } from './managers/${managerAvailable}.generated.js';\n`),
        ''
      );
      dts.replace(
        new RegExp(`readonly ${managerAvailable}: ${pascalCase(`${managerAvailable}Manager`)};\n`),
        ''
      );
    }
    else {
      dts.replace(
        new RegExp(`import { ${pascalCase(`${managerAvailable}Manager`)} } from './managers/${managerAvailable}.generated.js';`),
        `import { ${pascalCase(`${managerAvailable}Manager`)} } from 'box-typescript-sdk-gen/lib/managers/${managerAvailable}.generated.js';`
      );
    }
  }

  dts.trimLines().trim();

  return dts;
}
